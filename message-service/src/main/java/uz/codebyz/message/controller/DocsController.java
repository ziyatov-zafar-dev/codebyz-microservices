package uz.codebyz.message.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/docs/ws")
@Tag(name = "WebSocket Docs", description = "Command formats for WebSocket messaging service")
public class DocsController {

    @GetMapping(value = "/commands", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(
            summary = "List all WebSocket command types and payload schemas",
            description = "Use these JSON envelopes over WebSocket. Envelope format: {\"type\":<TYPE>, \"payload\":{...}}",
            responses = {
                    @ApiResponse(responseCode = "200", description = "Command reference returned",
                            content = @Content(array = @ArraySchema(schema = @Schema(implementation = CommandDoc.class))))
            }
    )
    public ResponseEntity<List<CommandDoc>> commands() {
        return ResponseEntity.ok(List.of(
                new CommandDoc("MESSAGE_SEND", Map.of(
                        "chatId", "UUID (required)",
                        "peerId", "UUID (required, other participant)",
                        "tempMessageId", "UUID (optional, client temp id)",
                        "content", "String (required for TEXT)",
                        "type", "TEXT|IMAGE|VIDEO|FILE",
                        "file", "Object{name,url,size} (optional)",
                        "replyToMessageId", "String (optional)",
                        "reactions", "Map<String, List<String>> (optional)"
                )),
                new CommandDoc("MESSAGE_EDIT", Map.of(
                        "chatId", "UUID (required)",
                        "messageId", "UUID string (required)",
                        "content", "String (required)"
                )),
                new CommandDoc("MESSAGE_DELETE", Map.of(
                        "chatId", "UUID (required)",
                        "messageId", "UUID string (required)"
                )),
                new CommandDoc("MESSAGE_READ", Map.of(
                        "chatId", "UUID (required)",
                        "messageId", "UUID string (required, read up to / including)"
                )),
                new CommandDoc("REACTION", Map.of(
                        "chatId", "UUID (required)",
                        "messageId", "UUID string (required)",
                        "emoji", "String (required)",
                        "add", "boolean (true=add, false=remove)"
                )),
                new CommandDoc("TYPING", Map.of(
                        "chatId", "UUID (required)",
                        "typing", "boolean (true=start, false=stop)"
                )),
                new CommandDoc("BLOCK", Map.of(
                        "chatId", "UUID (required)",
                        "block", "boolean (true=block peer, false=unblock)"
                )),
                new CommandDoc("EVENT_ACK", Map.of(
                        "chatId", "UUID (required)",
                        "lastEventSeq", "long (last received seq for replay)"
                ))
        ));
    }

    @GetMapping(value = "/handshake", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(
            summary = "Handshake and envelope format",
            description = "How to connect and send/receive events over WebSocket."
    )
    public ResponseEntity<HandshakeDoc> handshake() {
        HandshakeDoc doc = new HandshakeDoc(
                "/ws",
                "Authorization: Bearer <JWT>",
                Map.of(
                        "eventId", "UUID generated by server",
                        "eventType", "See EventType enum (e.g., MESSAGE_CREATED)",
                        "chatId", "UUID of chat",
                        "eventSeq", "Monotonic per chat for ordering",
                        "actorUserId", "UUID of sender; null for SYSTEM",
                        "timestamp", "ISO-8601 server timestamp",
                        "clientEventId", "Echo of client id for idempotency",
                        "payload", "Type-specific payload object"
                ),
                List.of(
                        "Connect via WebSocket to /ws with Authorization header.",
                        "Send commands as JSON: {\"type\":\"MESSAGE_SEND\",\"payload\":{...}}",
                        "On reconnect, send EVENT_ACK with lastEventSeq per chat to replay missed events.",
                        "Presence USER_ONLINE/OFFLINE and system messages are pushed automatically."
                )
        );
        return ResponseEntity.ok(doc);
    }

    public record CommandDoc(String type, Map<String, String> payloadFields) {}

    public record HandshakeDoc(
            String endpoint,
            String authHeader,
            Map<String, String> envelopeFields,
            List<String> notes
    ) {}
}
